# API Guidelines

## Введение

Программная архитектура цифровой трансформации Сибур построена вокруг слабо связанных микросервисов, которые предоставляют 
функциональность с помощью API. Проектные команды, владеют, разрабатывают, развертывают и поддерживают эти микросервисы.
API микросервисов максимально полно отражают свою функциональность. Разработка качественных, долговечных и производительных API, 
является приоритетной задачей.

API First является одним из наших ключевых принципов проектирования. Разработка микросервисов начинается с проектирования API.
Что в идеале включает в себя обширную обратную связь от клиентов API для получения высококачественных API-интерфейсов. 
API First включает в себя набор стандартов описанных в данном документе и поддерживает культуру коллегиального обзора. 
Мы призываем наши команды следовать им, чтобы гарантировать, что наши API:
- можно легко и быстро понять
- просты в использовании
- следуют единому стилю
- совместимы с API других команд и нашей глобальной архитектурой

В идеале все API-интерфейсы должны выглядеть так, как будто их создал один и тот же автор.

## Соглашения используемые в документе

Ключевые слова используемые для указания уровня требований должны быть интерпретированы как в [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt):
- ДОЛЖЕН, ТРЕБУЕТСЯ, ОБЯЗАН ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 1)
- НЕ ДОЛЖЕН, НЕ ТРЕБУЕТСЯ, НЕ ОБЯЗАН ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 2)
- РЕКОМЕНДУЕТСЯ ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 3)
- НЕ РЕКОМЕНДУЕТСЯ  ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 4)
- МОЖЕТ, ОПЦИОНАЛЬНО ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 5)

Данные слова используются напрямую в тексте, в любом регистре и допускаются различные окончания и другие способы словообразования.
Всё это не изменяет интерпретацию ключевых слов.

## Specific information

Цель документа "API Guidelines" в том, чтобы определить стандарты по разработке API, 
чтобы придать всем API "единый стиль и общий дух". Владельцами данного документа является представители различных проектных команд,
входящих в команду [API Guild](https://github.com/orgs/sibur/teams/api-guild),
его изменение проводится на основе голосования всеми участниками [API Guild](https://github.com/orgs/sibur/teams/api-guild). 
Решения о внесении изменений вносятся только с полного согласия с изменениями всех участников команды [API Guild](https://github.com/orgs/sibur/teams/api-guild),
то есть либо с изменением согласны все, либо оно отвергается.
 
Команды обязаны соблюдать данный документ во время разработки API. Любая команда может внести свой вклад в разработку руководящих принципов создав Pull request.
Рассмотрение, принятие или отклонение изменений внесенных в Pull request находится в компетенции команды [API Guild](https://github.com/orgs/sibur/teams/api-guild).

Эти руководящие принципы в какой-то мере будут изменяться и развиваться в процессе нашей работы, но команды могут уверенно следовать им и доверять им.

В случае когда API изменилось, следующие правила применяются:

- существующие API не обязаны изменяться, но это рекомендуется
- Новые API обязаны следовать новым правилам

При разработке API, любого микросервиса, разработчик обязан руководствоваться данными методическими
указаниями.

В качестве примера API, которое максимально следует данным рекомендациям в папке example содержится API, 
при разработке API с нуля рекомендуется брать данный шаблон за основу.

## Major principles
- API as a product: API должно разрабатываться так, как если бы оно могло бы быть открытым неопределенному
кругу лиц и могло бы решать их проблемы как целостный продукт.
- API first:  при разработке любого  микросервиса, с которым подразумевается внешнее взаимодействие,
разработка API является первичной и приоритетной.
- GRPC API Only: для описания API любого микросервиса должен использоваться 
только [GRPC](https://grpc.io/) интерфейс взаимодействия с ним, 
само API описывается с помощью [protocol-buffers proto3](https://developers.google.com/protocol-buffers/docs/proto3).
- One API for one microservice: любой  микросервис, должен иметь одно и только одно GRPC API,
и каждое API может быть реализовано только одним микросервисом.
- REST, We Can: так как в редких случаях необходим downgrade до REST, требуется использовать [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway),
а не реализовывать REST интерфейс микросервиса отдельно.
Замечание: из-за grpc-gateway мы вводим ограничения в proto-файлы (не можем использовать import), такое себе решение

- No magic: Несмотря на то, что GRPC позволяет указывать headers и мета-информацию, она не должна использоваться в запросах клиента, 
так как это не явная логика для клиента API и усложняет его понимание.
- Self-documenting API:  содержимое proto файлов должно быть прокомментировано до такой степени, чтобы было
полностью понятно, без дополнительной документации, стороннему клиенту.

## API Repository
- Для хранения исходных кодов API используется VCS GIT
- Все репозитории с API Должны храниться в [gitlab](https://gitlab.com/sibur/api) 
- Любой клиент который использует API подключает репозиторий как git submodule
Замечание: не считаю обязательным это вносить в guideline (в Visual Studio, к примеру из коробки не было возможности создать submodule, только "ручками"). Тут кто как хочет, так и ...

- Любой клиент следит за обновлениями репозитория API и самостоятельно обновляет submodule
- В названии можно использовать только нижний регистр, слова разделять с помощью - (hyphen)
- Имя репозитория API должно быть уникальным в рамках [gitlab](https://gitlab.com/sibur/api) 
- В имени репозитория не допускается использовать любые зарезервированные слова для любых языков
программирования
- В имени репозитория не допускается добавлять какие угодно префиксы или постфиксы, для отражения каких
угодно особенностей API, в.т.ч. private, public, external, internal, stable, dev, production и.т.п.

# Версионирование API
- До начала эксплуатации микросервиса в production окружении, версионирование не используется
- После начала эксплуатации API версионируется с помощью [семантического версионирования](https://semver.org/lang/ru/)
- Версионирование реализуется с помощью тегирования средствами Git master ветки в [gitlab](https://gitlab.com/sibur/api). 
- После начала эксплуатации API получает версию 1.0.0
- Изменения в API не должны ломать обратную совместимость, изменение API с обратной не совместимостью, обсуждаются в каждом случае отдельно
- Не должно использоваться версионирование в URI

# Repository structure
- Любой репозиторий с API в корне должен содержать файлы README.md, DOCUMENTATION.md, .gitignore и папку proto
- Папка proto должна содержать файл domain.proto
Что имеется в виду под "domain.proto"? Реально создается файл с таким наименованием или имеются в виду файлы сущностей (student.proto, university.proto)?
- Папка proto не должна содержать файлов кроме domain.proto

# README.md content
- должен содержать описание предметной области и то какую задачу решает API
- должен содержать глоссарий с определением всех терминов предметной области, которые используются в API
- должен содержать ссылку на DOCUMENTATION.md

# DOCUMENTATION.md content
- должен содержать автоматически сгенерированную документацию на основе domain.proto
- документация должна генерироваться с помощью [protoc-gen-doc](https://github.com/pseudomuto/protoc-gen-doc)
Замечание: не использовал. Работает независимо от платформы?

# API Host and port
- GRPC сервер микросервиса реализующий API должен быть доступен по следующему хосту:
{{repository-name}}.api.sibur.io, где {{repository-name}} идентично имени репозитория в [gitlab](https://gitlab.com/sibur/api),
- GRPC сервер микросервиса должен слушать порт 6565
Замечание: почему именно 6565? Почему не 82, к примеру?

- на домене api.sibur.io до начала промышленной эксплуатации, располагается staging экосистема микросервисов, в дальнейшем, возможно, 
потребуется пересмотр данного пункта

## Code Style rules

- API должно следовать следующему [code style](https://developers.google.com/protocol-buffers/docs/style)
- для отступов должна использоваться табуляция
- все rpc отделяются друг от друга одной строкой
- для комментирования должна использоваться // нотация
- все комментарии пишутся перед комментируемой сущностью, на отдельной строке
- все message, enum и service отделяются друг от друга одной строкой
- все параметры внутри message и enum отделяются друг от друга отступом в одну строку
- service должны именоваться в UpperCamelCase
- message должны именоваться в UpperCamelCase
- rpc должны именоваться в lowerCamelCase
- param должны именоваться в lower_snake_case
Замечание: это best-practice? почему не lower camel case?
- enum должны именоваться в UpperCamelCase
- enum param должны именоваться в SCREAMING_SNAKE_CASE

# domain.proto content and rules
- Апи должно быть написано на английском, за исключением комментариев
- Комментарии должны быть написаны либо на русском либо на английском
- domain.proto должен включать в себя все предметную область API
Так что же такое "domain.proto"?

- На первой строчке domain.proto должно содержаться указание syntax= 'proto3';
- на второй строчке должен быть указан package, после него отступ в одну строчку
- В имени пакета должен использоваться UpperCamelCase
Замечание: почему? best-practice?

- Для именования репозитория используется следующий шаблон: Api.Sibur.{{repositoryName}}
- не допускается использования import, за исключением: import "google/api/annotations.proto"; 
(данное требование связано с наличием в некоторых инструментах grpc-ecosystem багов, 
при использовании import, в частности [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) 
не верно расставляет package для сгенерированных файлов при использовании import, 
в следствии чего его становится невозможно использовать)
Замечание: не согласен! Что ж нам теперь все общие типы в каждом файле дублить? Не круто под специфику 3rd-party инструмента идти на компромиссы. У меня к примеру protoc.exe не понимает внутренности "option (google.api.http)" внутри "rpc", тупо не компилится. Я, получается, не могу использовать grpc-gateway.

- остальную часть файла занимают описания непосредственно API в следующем порядке: 
сначала идет объявление message модели предметной области,
 затем сервис, который отвечает за манипуляции с этой моделью,
  затем контейнер для request и response для сервиса, затем следующая модель итп.
- В конце файла должен находиться message Structures, который содержит общие для всего API структуры данных.
Нужно узнать подробности.

## Model message rules 
- под моделью понимается message, который является сущностью предметной области
- название модели должно быть существительным, однозначным и отражать сущность предметной области
- название модели не должно содержать зарезервированные слова для языков  программирования
- название модели не должно содержать какие угодно префиксы или постфиксы, для отражения каких
угодно особенностей, в.т.ч. private, public, external, internal, stable, dev, production, test, entity и.т.п.
- модель должна содержать внутри себя message Id, в котором задается уникальный ключ этой модели
- первое поле модели должен быть Id id = 1;
Замечание: почему бы не использовать int32, int64, GUID? зачем нам структура, чтоб передать id?

- Модели которые содержат связи с другими моделями должны связываться с ними через их Id, 
а не содержать саму структуру модели с которой есть связь
- Модель может содержать message Data, в данном message хранятся параметры, 
которые нужно указывать при создании модели с помощью метода create,
 а также те, которые можно свободно изменять методом update
 
## Service rules 
- Каждый service должен отвечать за одну и только одну модель предметной области
- Имя service формируется по шаблону {{Model}}Service
- Название rpc процедуры должно быть глаголом, отражающем суть выполняемой операции
- В названии rpc процедуры не должно дублироваться имя сервиса или его части
- Если сервис предполагает CRUD операции, то он должен содержать их с следующими именами: get, create, update, delete
Замечание: а если у есть метод, который отвечает за добавление и обновление одновременно? в 99% процентах случаев так оно и будет
createUpdate?

- Все rpc кроме get, create, update, delete должны быть прокомментированы
- Все rpc на вход получают request из соответствующего сервису пакета
- Все rpc на выход возвращают response из соответствующего сервису пакета
- Каждая rpc должна содержать option для описания в REST
Не компилируется option в protoc.exe, хоть ты тресни) я ее не использую.

- Для описания REST методов используется google.api.http
- В качестве pattern должен использоваться только post
Не согласен, получение данных - это get-запрос. А как же DELETE, PUT?

- путь в post указывается по следующему шаблону "/{{model}}/{{rpc}}", где model - имя модели предметной области, 
rpc - название rpc метода, UpperCamelCase и lowerCamelCase в названиях message и rpc заменяются на kebab-case
- В качестве body всегда указывается "*"ё
- Более сложные маппинги в рамках [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) не должны использоваться
- Маппинги на путь в post параметров запроса не должны использоваться

## Packet rules
- message с постфиксом в имени Packet должен хранить все Request и Response для одного service
- данный message именуется по принципу {{Model}}Packet 
- packet не должен содержать request и response других сервисов
- message с постфиксом в имени Packet не должен хранить другие message, кроме Request и Response 

## Request rules
- Все Request должны именоваться по принципу {{RpcName}}Request
- Первым параметром любого Request должен идти string jwt = 1; в котором содержится JWT auth token
Замечание: не любого. Зачем на получение общедоступной информации передавать JWT-токен авторизации?

- Рекомендуется делать Request максимально простым для клиента

## Response rules
- Все Response должны именоваться по принципу {{RpcName}}Response
- Все Response должны содержать oneof параметр result, где внутри результат выполнения команды или enum Error message
Замечание: нет, Error должен быть объектом, который содержит в себе enum и текст ошибки в человекочитаемом виде.
Желательно разделить Error на SingleError с одной потенциальной ошибкой и MultipleErrors с массивом ошибок, чтоб конечный пользователь сразу же понимал, какие ошибки он может потенциально получить (одну или много).

- Error должен быть enum и содержать список всех возможных ошибок
Замечание: нет, Error должен быть объектом, который содержит в себе enum и текст ошибки в человекочитаемом виде.

- Error должен в качестве первого элемента enum содержать INTERNAL_ERROR,
данная ошибка включает в себя любую не категоризированную или не учтенную ошибку
- Error должен в качестве второго элемента enum содержать FORBIDDEN, данная ошибка говорит о том, 
что пользователь не прошел аутентификацию или авторизацию
- результат выполнения команды может быть в любом удобном для клиента виде, 
но рекомендуется возвращать хотя бы модель предметной области, над которой проводились изменения

## Get Request и Response
- Запрос на получение списка модели предметной области должен быть сформирован по следующему шаблону:
```proto
syntax="proto3";
message GetRequest {
    string jwt = 1;
    repeated Scope scope = 2;
    uint64 offset = 3;
    uint64 length = 4;

    message Scope {
        oneof condition {
            ById by_id = 1;
            LikeFullName like_full_name = 2;
        }

        message ById {
            repeated SomeModel.Id id = 1;
            Замечание: зачем усложнять? просто int32 или int64
        }

        message LikeFullName {
            string full_name = 1;
        }
    }
}
```
- GetRequest может быть полностью пустым, если дополнительные условия поиска не предполагаются
Замечание: насколько я понял, пустой параметр мы не можем передать, необходимо создать "пустой" объект и его передавать. Это имелось в виду?

- message Scope содержит список условий к которые применяются к выборке
- допускается использовать как несколько условий, так и не использовать их вовсе
- message Scope должен содержать oneof condition внутри которого указываются предикаты условий
- В качестве предикатов выступают message внутри Scope, каждое из которых указывает какое-то конкретное условие
- Третьим параметром GetRequest должен идти uint64 offset, который указывает сдвиг выборки с начала до значения offset
- Четвертым параметром GetRequest должен идти uint64 length, который указывает максимальную длину выборки
- GetResponse должен быть сформирован по следующему шаблону: 
```proto
syntax="proto3";
message GetResponse {
        oneof result {
            Batch batch = 1;
            Batch data = 1; - мы сейчас так делаем, в качестве результат всегда приходит либо ошибка, либо объект с именем "data" - Леша Протасов попросил, надо обсудить.
            Error error = 2;
        }

        enum Error {
            INTERNAL_ERROR = 0;
            FORBIDDEN = 1;
            INVALID_SCOPE_CONDITION = 2;
        }

        message Batch {
            repeated SomeModel some_model = 1;
        }
    }
```
- oneof result в GetResponse должен содержать Batch, внутри которого содержится результат выборки, 
а именно модели предметной области

## Structures rules
- в конце файла domain.proto должен быть message Structures
Замечание: стоит обсудить.

- В данном message определяются message, которые могут использоваться всеми другими message

## Работа с временем
- для передачи метки времени между сервером и клиентов, должно осуществляться только с  помощью следующего message:
```proto
syntax="proto3";
    // Описания момента во времени. Определяется как количество милисекунд,
    // прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (четверг)
    message Timestamp {
        // количество милисекунд, прошедших c 00:00:00 UTC 01.01.1970
        int64 milliseconds = 1;
        Замечание: а как же гугловский формат seconds+nanos (https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto)?
    }
```
